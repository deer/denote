#!/usr/bin/env -S deno run -A
/**
 * Denote CLI â€” The documentation framework for Deno
 *
 * Usage:
 *   denote dev          Start development server
 *   denote build        Build for production
 *   denote mcp          Start MCP server
 */

import denoConfig from "./deno.json" with { type: "json" };
const VERSION = denoConfig.version;

// ANSI colors
const bold = (s: string) => `\x1b[1m${s}\x1b[0m`;
const green = (s: string) => `\x1b[32m${s}\x1b[0m`;
const cyan = (s: string) => `\x1b[36m${s}\x1b[0m`;
const dim = (s: string) => `\x1b[2m${s}\x1b[0m`;
const red = (s: string) => `\x1b[31m${s}\x1b[0m`;

function printHelp() {
  console.log(`
${bold("ðŸ¦• Denote")} v${VERSION} â€” AI-native documentation framework

${bold("USAGE")}
  denote <command> [options]

${bold("COMMANDS")}
  dev              Start development server
  build            Build static site for production
  validate         Check content, config, and navigation for issues
  mcp [--http]     Start MCP server for AI agents

${bold("OPTIONS")}
  -h, --help       Show this help message
  -v, --version    Show version number
  -p, --port       Port for dev server (default: 8000)

${bold("EXAMPLES")}
  denote dev                    ${dim("# Start dev server")}
  denote build                  ${dim("# Build for production")}
  denote mcp --http --port 3100 ${dim("# Start MCP server")}
`);
}

async function loadUserConfig(): Promise<
  { config: unknown; configPath: string }
> {
  const candidates = [
    "denote.config.ts",
    "denote.config.js",
  ];

  for (const name of candidates) {
    const absPath = `${Deno.cwd()}/${name}`;
    try {
      await Deno.stat(absPath);
      const mod = await import(`file://${absPath}`);
      return { config: mod.config || mod.default, configPath: absPath };
    } catch {
      // Try next
    }
  }

  console.error(red("Error: No config file found."));
  console.error(`Expected one of: ${candidates.join(", ")}`);
  console.error(
    `Run ${cyan("deno run -Ar jsr:@denote/init")} to create a new project.`,
  );
  Deno.exit(1);
}

/**
 * Resolve the @denote/core package directory.
 * Works both in development (relative import) and published (jsr import).
 */
function getDenotePkgDir(): string {
  return new URL(".", import.meta.url).pathname;
}

/**
 * Generate build files in the .denote/ hidden directory.
 * These are gitignored and regenerated by the CLI on every dev/build.
 */
async function generateBuildFiles(configPath: string, port = 8000) {
  const cwd = Deno.cwd();
  const dotDir = `${cwd}/.denote`;
  const denotePkgDir = getDenotePkgDir();
  const header = "// @denote-generated â€” do not edit, regenerated by CLI\n";

  // Ensure .denote/ directory exists
  await Deno.mkdir(dotDir, { recursive: true });

  // main.ts â€” entry point that Vite/Fresh uses
  await Deno.writeTextFile(
    `${dotDir}/main.ts`,
    `${header}import { denote } from "${denotePkgDir}mod.ts";
import { config } from "${configPath}";
import { join } from "jsr:@std/path@1";

const contentDir = Deno.env.get("DENOTE_CONTENT_DIR") ||
  join(Deno.cwd(), "content", "docs");

export const app = denote({ config, contentDir });
`,
  );

  // client.ts â€” client-side entry (CSS imports)
  await Deno.writeTextFile(
    `${dotDir}/client.ts`,
    `${header}import "./styles.css";
`,
  );

  // styles.css â€” Tailwind + Denote styles
  await Deno.writeTextFile(
    `${dotDir}/styles.css`,
    `/* @denote-generated â€” do not edit, regenerated by CLI */
@import "tailwindcss";

@source "${denotePkgDir}";
@source "../";

@variant dark (&:where(.dark, .dark *));

@import "${denotePkgDir}assets/styles.css";
`,
  );

  // vite.config.ts (includes config hot-reload plugin for dev)
  await Deno.writeTextFile(
    `${dotDir}/vite.config.ts`,
    `${header}import { defineConfig, type Plugin } from "vite";
import { fresh } from "@fresh/plugin-vite";
import tailwindcss from "@tailwindcss/vite";
import { setConfig } from "${denotePkgDir}lib/config.ts";

const DENOTE_CONFIG_PATH = "${configPath}";

const islandSpecifiers = [
  "${denotePkgDir}islands/ThemeToggle.tsx",
  "${denotePkgDir}islands/MobileMenu.tsx",
  "${denotePkgDir}islands/Search.tsx",
  "${denotePkgDir}islands/CollapsibleNav.tsx",
  "${denotePkgDir}islands/CopyButton.tsx",
  "${denotePkgDir}islands/ActiveToc.tsx",
  "${denotePkgDir}islands/AiChat.tsx",
];

/** Vite plugin: hot-reload denote.config.ts without restarting the dev server */
function denoteConfigHmr(): Plugin {
  return {
    name: "denote-config-hmr",
    configureServer(server) {
      server.watcher.on("change", async (file: string) => {
        if (file === DENOTE_CONFIG_PATH) {
          try {
            const mod = await import("file://" + DENOTE_CONFIG_PATH + "?t=" + Date.now());
            setConfig(mod.config || mod.default);
            console.log("  [denote] Config reloaded");
            server.hot.send({ type: "full-reload" });
          } catch (e: unknown) {
            const msg = e instanceof Error ? e.message : String(e);
            console.error("  [denote] Config reload error:", msg);
          }
        }
      });
    },
  };
}

export default defineConfig({
  plugins: [
    denoteConfigHmr(),
    fresh({ serverEntry: ".denote/main.ts", clientEntry: ".denote/client.ts", islandSpecifiers }),
    tailwindcss(),
  ],
  server: {
    port: ${port},
    host: true,
  },
});
`,
  );
}

async function devCommand(port: number) {
  const { configPath } = await loadUserConfig();

  console.log(`\n${bold("ðŸ¦• Denote")} ${dim(`v${VERSION}`)}`);
  console.log(`${dim("  Config:")} ${configPath}`);
  console.log(`${dim("  Server:")} ${cyan(`http://localhost:${port}`)}\n`);

  await generateBuildFiles(configPath, port);

  // Run vite dev from .denote/ â€” config hot-reload is handled by the generated Vite plugin
  const command = new Deno.Command(Deno.execPath(), {
    args: ["run", "-A", "npm:vite", "--config", ".denote/vite.config.ts"],
    cwd: Deno.cwd(),
    stdout: "inherit",
    stderr: "inherit",
  });

  const child = command.spawn();
  await child.status;
}

async function buildCommand() {
  const { configPath } = await loadUserConfig();

  console.log(`\n${bold("ðŸ¦• Denote Build")} ${dim(`v${VERSION}`)}`);
  console.log(`${dim("  Config:")} ${configPath}\n`);

  await generateBuildFiles(configPath);

  // Run vite build from .denote/
  const command = new Deno.Command(Deno.execPath(), {
    args: [
      "run",
      "-A",
      "npm:vite",
      "build",
      "--config",
      ".denote/vite.config.ts",
    ],
    cwd: Deno.cwd(),
    stdout: "inherit",
    stderr: "inherit",
  });

  const { code } = await command.output();
  if (code !== 0) {
    console.error(red("\nBuild failed."));
    Deno.exit(code);
  }

  console.log(green("\nâœ“ Build complete!"));
  console.log(dim("  Output: _fresh/\n"));
}

// â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if (import.meta.main) {
  const args = Deno.args;
  const command = args[0];

  if (!command || args.includes("-h") || args.includes("--help")) {
    printHelp();
    Deno.exit(0);
  }

  if (args.includes("-v") || args.includes("--version")) {
    console.log(`denote ${VERSION}`);
    Deno.exit(0);
  }

  // Parse --port
  const portIdx = args.indexOf("--port") !== -1
    ? args.indexOf("--port")
    : args.indexOf("-p");
  const port = portIdx !== -1 ? parseInt(args[portIdx + 1]) || 8000 : 8000;

  switch (command) {
    case "dev":
      await devCommand(port);
      break;

    case "build":
      await buildCommand();
      break;

    case "validate": {
      const { config } = await loadUserConfig();
      const { resolve } = await import("@std/path");
      const { validateAndPrint } = await import("./lib/validate.ts");
      const denoteContext = {
        config: config as import("./denote.config.ts").DenoteConfig,
        contentDir: resolve("./content/docs"),
        docsBasePath: "/docs",
      };
      const errorCount = await validateAndPrint(denoteContext);
      Deno.exit(errorCount > 0 ? 1 : 0);
      break;
    }

    case "mcp": {
      // Delegate to the existing mcp.ts with remaining args
      const mcpArgs = args.slice(1);
      // Dynamically import and the mcp.ts handles its own execution
      const mcpPath = new URL("./mcp.ts", import.meta.url).href;
      // Set Deno.args-like behavior by re-running
      const cmd = new Deno.Command(Deno.execPath(), {
        args: ["run", "-A", mcpPath, ...mcpArgs],
        stdout: "inherit",
        stderr: "inherit",
        stdin: "inherit",
      });
      const { code } = await cmd.output();
      Deno.exit(code);
      break;
    }

    default:
      console.error(red(`Unknown command: ${command}`));
      console.error(`Run ${cyan("denote --help")} for usage.`);
      Deno.exit(1);
  }
}
