#!/usr/bin/env -S deno run -A
/**
 * Denote CLI â€” The documentation framework for Deno
 *
 * Usage:
 *   denote dev          Start development server
 *   denote build        Build for production
 *   denote init [dir]   Scaffold a new project
 *   denote mcp          Start MCP server
 */

const VERSION = "0.0.1";

// ANSI colors
const bold = (s: string) => `\x1b[1m${s}\x1b[0m`;
const green = (s: string) => `\x1b[32m${s}\x1b[0m`;
const cyan = (s: string) => `\x1b[36m${s}\x1b[0m`;
const dim = (s: string) => `\x1b[2m${s}\x1b[0m`;
const red = (s: string) => `\x1b[31m${s}\x1b[0m`;

function printHelp() {
  console.log(`
${bold("ðŸ¦• Denote")} v${VERSION} â€” AI-native documentation framework

${bold("USAGE")}
  denote <command> [options]

${bold("COMMANDS")}
  dev              Start development server
  build            Build static site for production
  init [dir]       Scaffold a new Denote project
  mcp [--http]     Start MCP server for AI agents

${bold("OPTIONS")}
  -h, --help       Show this help message
  -v, --version    Show version number
  -p, --port       Port for dev server (default: 8000)

${bold("EXAMPLES")}
  denote dev                    ${dim("# Start dev server")}
  denote build                  ${dim("# Build for production")}
  denote init my-docs           ${dim("# Create new project")}
  denote mcp --http --port 3100 ${dim("# Start MCP server")}
`);
}

async function loadUserConfig(): Promise<
  { config: unknown; configPath: string }
> {
  const candidates = [
    "denote.config.ts",
    "denote.config.js",
    "docs.config.ts",
    "docs.config.js",
  ];

  for (const name of candidates) {
    const absPath = `${Deno.cwd()}/${name}`;
    try {
      await Deno.stat(absPath);
      const mod = await import(`file://${absPath}`);
      return { config: mod.config || mod.default, configPath: absPath };
    } catch {
      // Try next
    }
  }

  console.error(red("Error: No config file found."));
  console.error(`Expected one of: ${candidates.join(", ")}`);
  console.error(`Run ${cyan("denote init")} to create a new project.`);
  Deno.exit(1);
}

/**
 * Resolve the @denote/core package directory.
 * Works both in development (relative import) and published (jsr import).
 */
function getDenotePkgDir(): string {
  return new URL(".", import.meta.url).pathname;
}

/**
 * Generate the hidden .denote/ directory with vite.config.ts, client.ts,
 * styles.css, and main.ts â€” everything Vite/Fresh needs to run.
 */
/**
 * Generate build files in the project root that Vite/Fresh needs.
 * These are gitignored and marked as auto-generated.
 */
async function generateBuildFiles(configPath: string, port = 8000) {
  const cwd = Deno.cwd();
  const denotePkgDir = getDenotePkgDir();
  const header = "// @denote-generated â€” do not edit, regenerated by CLI\n";

  // main.ts â€” entry point that Vite/Fresh uses
  await Deno.writeTextFile(
    `${cwd}/main.ts`,
    `${header}import { denote } from "${denotePkgDir}mod.ts";
import { config } from "${configPath}";
import { join } from "jsr:@std/path@1";

const contentDir = Deno.env.get("DENOTE_CONTENT_DIR") ||
  join(Deno.cwd(), "content", "docs");

export const app = denote({ config, contentDir });
`,
  );

  // client.ts â€” client-side entry (CSS imports)
  await Deno.writeTextFile(
    `${cwd}/client.ts`,
    `${header}import "./styles.css";
`,
  );

  // styles.css â€” Tailwind + Denote styles
  await Deno.writeTextFile(
    `${cwd}/styles.css`,
    `/* @denote-generated â€” do not edit, regenerated by CLI */
@import "tailwindcss";

@source "${denotePkgDir}";
@source "./";

@variant dark (&:where(.dark, .dark *));

@import "${denotePkgDir}assets/styles.css";
`,
  );

  // vite.config.ts
  await Deno.writeTextFile(
    `${cwd}/vite.config.ts`,
    `${header}import { defineConfig } from "vite";
import { fresh } from "@fresh/plugin-vite";
import tailwindcss from "@tailwindcss/vite";

const islandSpecifiers = [
  "${denotePkgDir}islands/ThemeToggle.tsx",
  "${denotePkgDir}islands/MobileMenu.tsx",
  "${denotePkgDir}islands/Search.tsx",
  "${denotePkgDir}islands/CollapsibleNav.tsx",
  "${denotePkgDir}islands/CopyButton.tsx",
  "${denotePkgDir}islands/ActiveToc.tsx",
  "${denotePkgDir}islands/AiChat.tsx",
];

export default defineConfig({
  plugins: [
    fresh({ islandSpecifiers }),
    tailwindcss(),
  ],
  server: {
    port: ${port},
    host: true,
  },
});
`,
  );
}

async function devCommand(port: number) {
  const { configPath } = await loadUserConfig();

  console.log(`\n${bold("ðŸ¦• Denote")} ${dim(`v${VERSION}`)}`);
  console.log(`${dim("  Config:")} ${configPath}`);
  console.log(`${dim("  Server:")} ${cyan(`http://localhost:${port}`)}\n`);

  await generateBuildFiles(configPath, port);

  // Run vite dev
  const command = new Deno.Command(Deno.execPath(), {
    args: ["run", "-A", "npm:vite"],
    cwd: Deno.cwd(),
    stdout: "inherit",
    stderr: "inherit",
  });

  const child = command.spawn();
  await child.status;
}

async function buildCommand() {
  const { configPath } = await loadUserConfig();

  console.log(`\n${bold("ðŸ¦• Denote Build")} ${dim(`v${VERSION}`)}`);
  console.log(`${dim("  Config:")} ${configPath}\n`);

  await generateBuildFiles(configPath);

  // Run vite build
  const command = new Deno.Command(Deno.execPath(), {
    args: ["run", "-A", "npm:vite", "build"],
    cwd: Deno.cwd(),
    stdout: "inherit",
    stderr: "inherit",
  });

  const { code } = await command.output();
  if (code !== 0) {
    console.error(red("\nBuild failed."));
    Deno.exit(code);
  }

  console.log(green("\nâœ“ Build complete!"));
  console.log(dim("  Output: _fresh/\n"));
}

async function initCommand(projectDir: string, projectName: string) {
  console.log(
    `\n${bold("ðŸ¦• Creating Denote project:")} ${cyan(projectName)}\n`,
  );

  // Create directory structure
  const dirs = ["", "content/docs", "static"];

  for (const dir of dirs) {
    const path = `${projectDir}/${dir}`;
    await Deno.mkdir(path, { recursive: true });
  }

  // Create deno.json
  const denoJson = {
    tasks: {
      dev: "deno run -A jsr:@denote/core/cli dev",
      build: "deno run -A jsr:@denote/core/cli build",
      mcp: "deno run -A jsr:@denote/core/cli mcp",
    },
    imports: {
      "@denote/core": "jsr:@denote/core@^0.1.0",
    },
  };
  await Deno.writeTextFile(
    `${projectDir}/deno.json`,
    JSON.stringify(denoJson, null, 2) + "\n",
  );
  console.log(`  ${green("âœ“")} deno.json`);

  // Create denote.config.ts
  const configContent = `import type { DocsConfig } from "@denote/core";

export const config: DocsConfig = {
  name: "${projectName}",
  colors: {
    primary: "#6366f1",
  },
  navigation: [
    {
      title: "Getting Started",
      children: [
        { title: "Introduction", href: "/docs/introduction" },
        { title: "Installation", href: "/docs/installation" },
      ],
    },
  ],
  topNav: [
    { title: "Documentation", href: "/docs" },
  ],
  social: {
    github: "https://github.com/your-org/${projectName}",
  },
  footer: {
    copyright: "Â© ${new Date().getFullYear()} ${projectName}",
  },
  search: {
    enabled: true,
  },
};
`;
  await Deno.writeTextFile(`${projectDir}/denote.config.ts`, configContent);
  console.log(`  ${green("âœ“")} denote.config.ts`);

  // Create introduction.md
  const introMd = `---
title: Introduction
description: Welcome to ${projectName}
---

# Welcome to ${projectName}

This is your documentation site, powered by **Denote**.

## Features

- ðŸ“ **Markdown First** â€” Write docs in plain Markdown
- âš¡ **Lightning Fast** â€” Server-rendered with Fresh v2
- ðŸ¤– **AI Native** â€” Built-in MCP server, llms.txt, and JSON API
- ðŸ” **Full-text Search** â€” Instant âŒ˜K search

## Next Steps

1. Edit this page in \`content/docs/introduction.md\`
2. Add more pages to \`content/docs/\`
3. Update navigation in \`denote.config.ts\`

> [!TIP]
> Run \`deno task dev\` to start the development server.
`;
  await Deno.writeTextFile(
    `${projectDir}/content/docs/introduction.md`,
    introMd,
  );
  console.log(`  ${green("âœ“")} content/docs/introduction.md`);

  // Create installation.md
  const installMd = `---
title: Installation
description: How to install and set up ${projectName}
---

# Installation

Get started with ${projectName} in minutes.

## Prerequisites

- [Deno](https://deno.land) v2.0 or later

## Quick Start

\`\`\`bash
# Start the dev server
deno task dev
\`\`\`

Open [http://localhost:8000](http://localhost:8000) to see your docs.

## Project Structure

\`\`\`
${projectName}/
â”œâ”€â”€ content/docs/       # Your Markdown documentation
â”œâ”€â”€ static/             # Static assets (images, etc.)
â”œâ”€â”€ denote.config.ts    # Site configuration
â””â”€â”€ deno.json           # Deno configuration
\`\`\`

That's it! No build pipeline, no framework boilerplate. Just markdown and config.
`;
  await Deno.writeTextFile(
    `${projectDir}/content/docs/installation.md`,
    installMd,
  );
  console.log(`  ${green("âœ“")} content/docs/installation.md`);

  // Create .gitignore
  const gitignore = `# Build output
_fresh/
dist/

# Dependencies
node_modules/

# IDE
.vscode/
.idea/

# OS
.DS_Store
`;
  await Deno.writeTextFile(`${projectDir}/.gitignore`, gitignore);
  console.log(`  ${green("âœ“")} .gitignore`);

  // Done!
  console.log(`
${green(bold("âœ“ Project created!"))}

  ${dim("cd")} ${projectName}
  ${dim("deno task")} dev

  Then open ${cyan("http://localhost:8000")}
`);
}

// â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if (import.meta.main) {
  const args = Deno.args;
  const command = args[0];

  if (!command || args.includes("-h") || args.includes("--help")) {
    printHelp();
    Deno.exit(0);
  }

  if (args.includes("-v") || args.includes("--version")) {
    console.log(`denote ${VERSION}`);
    Deno.exit(0);
  }

  // Parse --port
  const portIdx = args.indexOf("--port") !== -1
    ? args.indexOf("--port")
    : args.indexOf("-p");
  const port = portIdx !== -1 ? parseInt(args[portIdx + 1]) || 8000 : 8000;

  switch (command) {
    case "dev":
      await devCommand(port);
      break;

    case "build":
      await buildCommand();
      break;

    case "init": {
      const projectArg = args[1] || ".";
      const projectDir = projectArg === "."
        ? Deno.cwd()
        : `${Deno.cwd()}/${projectArg}`;
      const projectName = projectArg === "."
        ? Deno.cwd().split("/").pop()!
        : projectArg;

      // Check if directory exists and has files
      try {
        const stat = await Deno.stat(projectDir);
        if (stat.isDirectory && projectArg !== ".") {
          const entries = [];
          for await (const entry of Deno.readDir(projectDir)) {
            entries.push(entry);
          }
          if (entries.length > 0) {
            console.error(
              red(
                `Error: Directory '${projectArg}' already exists and is not empty.`,
              ),
            );
            Deno.exit(1);
          }
        }
      } catch {
        // Directory doesn't exist, that's fine
      }

      await initCommand(projectDir, projectName);
      break;
    }

    case "mcp": {
      // Delegate to the existing mcp.ts with remaining args
      const mcpArgs = args.slice(1);
      // Dynamically import and the mcp.ts handles its own execution
      const mcpPath = new URL("./mcp.ts", import.meta.url).href;
      // Set Deno.args-like behavior by re-running
      const cmd = new Deno.Command(Deno.execPath(), {
        args: ["run", "-A", mcpPath, ...mcpArgs],
        stdout: "inherit",
        stderr: "inherit",
        stdin: "inherit",
      });
      const { code } = await cmd.output();
      Deno.exit(code);
      break;
    }

    default:
      console.error(red(`Unknown command: ${command}`));
      console.error(`Run ${cyan("denote --help")} for usage.`);
      Deno.exit(1);
  }
}
