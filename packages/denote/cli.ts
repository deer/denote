#!/usr/bin/env -S deno run -A
/**
 * Denote CLI â€” The documentation framework for Deno
 *
 * Usage:
 *   denote dev          Start development server
 *   denote build        Build for production
 *   denote mcp          Start MCP server
 */

import denoConfig from "./deno.json" with { type: "json" };
const VERSION = denoConfig.version;

// ANSI colors
const bold = (s: string) => `\x1b[1m${s}\x1b[0m`;
const green = (s: string) => `\x1b[32m${s}\x1b[0m`;
const cyan = (s: string) => `\x1b[36m${s}\x1b[0m`;
const dim = (s: string) => `\x1b[2m${s}\x1b[0m`;
const red = (s: string) => `\x1b[31m${s}\x1b[0m`;

function printHelp() {
  console.log(`
${bold("ðŸ¦• Denote")} v${VERSION} â€” AI-native documentation framework

${bold("USAGE")}
  denote <command> [options]

${bold("COMMANDS")}
  dev              Start development server
  build            Build static site for production
  mcp [--http]     Start MCP server for AI agents

${bold("OPTIONS")}
  -h, --help       Show this help message
  -v, --version    Show version number
  -p, --port       Port for dev server (default: 8000)

${bold("EXAMPLES")}
  denote dev                    ${dim("# Start dev server")}
  denote build                  ${dim("# Build for production")}
  denote mcp --http --port 3100 ${dim("# Start MCP server")}
`);
}

async function loadUserConfig(): Promise<
  { config: unknown; configPath: string }
> {
  const candidates = [
    "denote.config.ts",
    "denote.config.js",
    "docs.config.ts",
    "docs.config.js",
  ];

  for (const name of candidates) {
    const absPath = `${Deno.cwd()}/${name}`;
    try {
      await Deno.stat(absPath);
      const mod = await import(`file://${absPath}`);
      return { config: mod.config || mod.default, configPath: absPath };
    } catch {
      // Try next
    }
  }

  console.error(red("Error: No config file found."));
  console.error(`Expected one of: ${candidates.join(", ")}`);
  console.error(`Run ${cyan("denote init")} to create a new project.`);
  Deno.exit(1);
}

/**
 * Resolve the @denote/core package directory.
 * Works both in development (relative import) and published (jsr import).
 */
function getDenotePkgDir(): string {
  return new URL(".", import.meta.url).pathname;
}

/**
 * Generate the hidden .denote/ directory with vite.config.ts, client.ts,
 * styles.css, and main.ts â€” everything Vite/Fresh needs to run.
 */
/**
 * Generate build files in the project root that Vite/Fresh needs.
 * These are gitignored and marked as auto-generated.
 */
async function generateBuildFiles(configPath: string, port = 8000) {
  const cwd = Deno.cwd();
  const denotePkgDir = getDenotePkgDir();
  const header = "// @denote-generated â€” do not edit, regenerated by CLI\n";

  // main.ts â€” entry point that Vite/Fresh uses
  await Deno.writeTextFile(
    `${cwd}/main.ts`,
    `${header}import { denote } from "${denotePkgDir}mod.ts";
import { config } from "${configPath}";
import { join } from "jsr:@std/path@1";

const contentDir = Deno.env.get("DENOTE_CONTENT_DIR") ||
  join(Deno.cwd(), "content", "docs");

export const app = denote({ config, contentDir });
`,
  );

  // client.ts â€” client-side entry (CSS imports)
  await Deno.writeTextFile(
    `${cwd}/client.ts`,
    `${header}import "./styles.css";
`,
  );

  // styles.css â€” Tailwind + Denote styles
  await Deno.writeTextFile(
    `${cwd}/styles.css`,
    `/* @denote-generated â€” do not edit, regenerated by CLI */
@import "tailwindcss";

@source "${denotePkgDir}";
@source "./";

@variant dark (&:where(.dark, .dark *));

@import "${denotePkgDir}assets/styles.css";
`,
  );

  // vite.config.ts
  await Deno.writeTextFile(
    `${cwd}/vite.config.ts`,
    `${header}import { defineConfig } from "vite";
import { fresh } from "@fresh/plugin-vite";
import tailwindcss from "@tailwindcss/vite";

const islandSpecifiers = [
  "${denotePkgDir}islands/ThemeToggle.tsx",
  "${denotePkgDir}islands/MobileMenu.tsx",
  "${denotePkgDir}islands/Search.tsx",
  "${denotePkgDir}islands/CollapsibleNav.tsx",
  "${denotePkgDir}islands/CopyButton.tsx",
  "${denotePkgDir}islands/ActiveToc.tsx",
  "${denotePkgDir}islands/AiChat.tsx",
];

export default defineConfig({
  plugins: [
    fresh({ islandSpecifiers }),
    tailwindcss(),
  ],
  server: {
    port: ${port},
    host: true,
  },
});
`,
  );
}

async function devCommand(port: number) {
  const { configPath } = await loadUserConfig();

  console.log(`\n${bold("ðŸ¦• Denote")} ${dim(`v${VERSION}`)}`);
  console.log(`${dim("  Config:")} ${configPath}`);
  console.log(`${dim("  Server:")} ${cyan(`http://localhost:${port}`)}\n`);

  await generateBuildFiles(configPath, port);

  // Run vite dev
  const command = new Deno.Command(Deno.execPath(), {
    args: ["run", "-A", "npm:vite"],
    cwd: Deno.cwd(),
    stdout: "inherit",
    stderr: "inherit",
  });

  const child = command.spawn();
  await child.status;
}

async function buildCommand() {
  const { configPath } = await loadUserConfig();

  console.log(`\n${bold("ðŸ¦• Denote Build")} ${dim(`v${VERSION}`)}`);
  console.log(`${dim("  Config:")} ${configPath}\n`);

  await generateBuildFiles(configPath);

  // Run vite build
  const command = new Deno.Command(Deno.execPath(), {
    args: ["run", "-A", "npm:vite", "build"],
    cwd: Deno.cwd(),
    stdout: "inherit",
    stderr: "inherit",
  });

  const { code } = await command.output();
  if (code !== 0) {
    console.error(red("\nBuild failed."));
    Deno.exit(code);
  }

  console.log(green("\nâœ“ Build complete!"));
  console.log(dim("  Output: _fresh/\n"));
}

// â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if (import.meta.main) {
  const args = Deno.args;
  const command = args[0];

  if (!command || args.includes("-h") || args.includes("--help")) {
    printHelp();
    Deno.exit(0);
  }

  if (args.includes("-v") || args.includes("--version")) {
    console.log(`denote ${VERSION}`);
    Deno.exit(0);
  }

  // Parse --port
  const portIdx = args.indexOf("--port") !== -1
    ? args.indexOf("--port")
    : args.indexOf("-p");
  const port = portIdx !== -1 ? parseInt(args[portIdx + 1]) || 8000 : 8000;

  switch (command) {
    case "dev":
      await devCommand(port);
      break;

    case "build":
      await buildCommand();
      break;

    case "mcp": {
      // Delegate to the existing mcp.ts with remaining args
      const mcpArgs = args.slice(1);
      // Dynamically import and the mcp.ts handles its own execution
      const mcpPath = new URL("./mcp.ts", import.meta.url).href;
      // Set Deno.args-like behavior by re-running
      const cmd = new Deno.Command(Deno.execPath(), {
        args: ["run", "-A", mcpPath, ...mcpArgs],
        stdout: "inherit",
        stderr: "inherit",
        stdin: "inherit",
      });
      const { code } = await cmd.output();
      Deno.exit(code);
      break;
    }

    default:
      console.error(red(`Unknown command: ${command}`));
      console.error(`Run ${cyan("denote --help")} for usage.`);
      Deno.exit(1);
  }
}
